install.packages("EBImage")
library(png)
readPNG("https://github.com/emmwilson/exploits_predictions/blob/f21d4f3b41a6d8e2b940a71faf2dc37451d0e730/data/invert.png")
aPNGFile <- "https://github.com/emmwilson/exploits_predictions/blob/f21d4f3b41a6d8e2b940a71faf2dc37451d0e730/data/invert.png"
download.file(aPNGFile,
"./data/invert.png",mode="wb")
url_embed = URL.createObjectURL(data/embed.png)
install.packages("swatches")
pacman::p_load(shades,
ggplot2)
colorRampPalette(c("#f47c3c","#d9534f"))
#| include: false
pacman::p_load(shiny,
bslib,
ggplot2,
ggtext,
shinythemes,
thematic,
tidyverse,
httr,
leaflet,
leafem,
terra,
htmltools,
glue,
cowplot)
#| include: false
# import layers
## river extent
TN_drainage <- vect("data/spatial data/Terranova_basin.shp") |>
project("EPSG:4326 - WGS 84")
## all rivers
TN_river <- vect("data/spatial data/Terranova_rivers.shp") |>
project("EPSG:4326 - WGS 84")
## lakes
TN_lakes <- vect("data/spatial data/Terranova_lakes.shp") |>
project("EPSG:4326 - WGS 84")
# import arrow
arrow <- "https://cdn.pixabay.com/photo/2013/07/12/17/54/arrow-152596_960_720.png"
View(TN_river)
TN_river@pntr[["names"]]
#| include: false
# use river reach data to predict outcomes
predictions_reaches <- TN_river
#| include: false
# use river reach data to predict outcomes
predictions_reaches <- TN_river
# values from Ky's presentation
ps <- 2650 # kg/m3, density of sediment
p <- 2000 # kg/m3, density of water
g <- 9.80665 # m/s2, acceleration by gravity
n <- 0.04 # channel roughness coefficient
t <- 0.04 # shields parameter
## predict responses based on data from field at each reach
predictions_reaches$width <- predictions_reaches$ria_ha_csu/predictions_reaches$LENGTH_KM
predictions_reaches$tb <- p*g*(n^(3/5))*((predictions_reaches$DIS_AV_CMS/predictions_reaches$width)^(3/5))*(predictions_reaches$sgr_dk_rav^(7/10))
predictions_reaches$D50 <- predictions_reaches$tb/(ps-p)*g*t  ## input your own formulas here
#| include: false
#colour palettes for predictions
# invert.pal <- colorNumeric(c("#f47c3c", "#d9534f"), domain = predictions_reaches$invert, na.color = "transparent")
# embed.pal <- colorNumeric(c("#e9c602", "#93c54b"), domain =  predictions_reaches$embed, na.color = "transparent")
# colour palette for discharge
discharge.pal <- colorNumeric(c("#dfdce3", "#8900a8"), domain = TN_river$DIS_AV_CMS, na.color = "transparent")
# colour palette for width
order.pal <- colorFactor(c("#d4021d", "#f2ca97"), domain = TN_river$ORD_CLAS, na.color = "transparent") # use this function for any categorical data you want to include in the map
# colour palette for stream gradient
# colour palette for D50
catchment.pal <- colorNumeric(c("#e9c602", "#00b80c"), domain = TN_river$UPLAND_SKM, na.color = "transparent")
#| include: false
# use river reach data to predict outcomes
# values from Ky's presentation
ps <- 2650 # kg/m3, density of sediment
p <- 2000 # kg/m3, density of water
g <- 9.80665 # m/s2, acceleration by gravity
n <- 0.04 # channel roughness coefficient
t <- 0.04 # shields parameter
## predict responses based on data from field at each reach
TN_river$width <- TN_river$ria_ha_csu/TN_river$LENGTH_KM
TN_river$tb <- p*g*(n^(3/5))*((TN_river$DIS_AV_CMS/TN_river$width)^(3/5))*(TN_river$sgr_dk_rav^(7/10))
TN_river$D50 <- TN_river$tb/(ps-p)*g*t  ## input your own formulas here
View(TN_river)
TN_river$D50
max(TN_river$D50)
plot(TN_river[D50])
plot(TN_river$D50)
plot(TN_river, "D50")
TN_river$D50
#| include: false
# import layers
## river extent
TN_drainage <- vect("data/spatial data/Terranova_basin.shp") |>
project("EPSG:4326 - WGS 84")
## all rivers
TN_river <- vect("data/spatial data/Terranova_rivers.shp") |>
project("EPSG:4326 - WGS 84")
## lakes
TN_lakes <- vect("data/spatial data/Terranova_lakes.shp") |>
project("EPSG:4326 - WGS 84")
# import arrow
arrow <- "https://cdn.pixabay.com/photo/2013/07/12/17/54/arrow-152596_960_720.png"
#| include: false
# use river reach data to predict outcomes
# values from Ky's presentation
ps <- 2650 # kg/m3, density of sediment
p <- 2000 # kg/m3, density of water
g <- 9.80665 # m/s2, acceleration by gravity
n <- 0.04 # channel roughness coefficient
t <- 0.04 # shields parameter
## predict responses based on data from field at each reach
TN_river$width <- TN_river$ria_ha_csu/100*TN_river$LENGTH_KM # area was in hectares
TN_river$tb <- p*g*(n^(3/5))*((TN_river$DIS_AV_CMS/TN_river$width)^(3/5))*(TN_river$sgr_dk_rav^(7/10))
TN_river$D50 <- TN_river$tb/(ps-p)*g*t  ## input your own formulas here
plot(TN_river, "D50")
TN_river$width <- TN_river$ria_ha_csu/TN_river$LENGTH_KM # area was in hectares
TN_river$tb <- p*g*(n^(3/5))*((TN_river$DIS_AV_CMS/TN_river$width)^(3/5))*(TN_river$sgr_dk_rav^(7/10))
TN_river$D50 <- TN_river$tb/(ps-p)*g*t
plot(TN_river, "D50")
plot(TN_river$sgr_dk_rav)
TN_river$tb
TN_river$width
## predict responses based on data from field at each reach
TN_river$width <- (TN_river$ria_ha_csu/TN_river$LENGTH_KM)*10
TN_river$tb <- p*g*(n^(3/5))*((TN_river$DIS_AV_CMS/TN_river$width)^(3/5))*(TN_river$sgr_dk_rav^(7/10))
TN_river$D50 <- TN_river$tb/(ps-p)*g*t  ## input your own formulas here
TN_river$width
TN_river$tb
TN_river$sgr_dk_rav
TN_river$tb <- p*g*(n^(3/5))*((TN_river$DIS_AV_CMS/TN_river$width)^(3/5))*((TN_river$sgr_dk_rav/10000)^(7/10))
TN_river$tb
TN_river$sgr_dk_rav/10000
